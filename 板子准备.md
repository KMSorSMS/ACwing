## 板子

#### STL使用

+ [x] pair
+ [x] set、multiset、map、multimap [链接](https://www.zhihu.com/question/483925779)

#### 数据结构

+ [x] [线段树](#线段树)
+ [x] [树状数组](#树状数组)
+ [x] [KMP](#KMP)
+ [x] [AC自动机](#AC自动机)
+ [x] [并查集](#并查集)
+ [x] [st表](#st表)
+ [x] [Splay 树](#Splay树)

#### 经典算法

+ [x] 最短路
    + [x] [Dijkstra](#Dijkstra)
    + [x] [Floyd](#Floyd)
    + [x] [SPFA](#SPFA（队列优化）)
+ [x] 最小生成树
    + [x] [Kruskal](#Kruskal)
    + [x] [Prim](#Prime)
+ [x] [图的连通性](#图的连通性)
    + [x] [Tarjan](#Tarjan)
+ [ ] [二分图](#二分图)
    + [x] [匈牙利算法](#匈牙利算法 ) 
    + [ ] [KM 算法](#KM算法)
+ [ ] [网络流](#网络流)
+ [x] [拓扑排序](#拓扑排序)

#### 数学

+ [x] [快速幂](#快速幂)
+ [x] [求组合数](#求组合数)
+ [x] [素数筛法](#素数筛法)
+ [x] [大整数乘法](#大整数乘法)
+ [x] [进制转化](#进制转化)
+ [x] [快速傅里叶变换](#FFT)

### GCC 11 命令行编译

```
gcc main1.c sub1.o -o main1
```

### STL使用

##### pair

```c++
#include<utility>
typedef pair<int,int> P;

P p = P(0,s); // 快速初始化一个pair 例如：que.push(P(0,s));
p.first;
p.second;
// pair 之间的比较遵守字典序，即先比较 first，再比较 second
// 详情可见 Dijkstra 算法中对于 pair 的使用
```

##### set

set::insert(key)的返回值是一个pair<iterator, bool>，其中pair中的bool成员表明了key被插入之前set中是否已存在相同的key，若存在则不插入；而multiset::insert的返回值只是一个iterator，插入操作总是被允许的。

```c++
using namespace std;

int main(){
	set<int> st;
	int n = 5;
	for(int i=0;i<n;i++)
		st.insert(i);
	for(int i=0;i<n;i++)
		st.insert(i);
	// 遍历  
	for(set<int>::iterator it=st.begin();it!=st.end();it++){
		cout << *it << " ";
	}
	cout << endl;
	// 计数
	cout << "count 3:" << st.count(3) << endl; // 1
	st.erase(st.find(3));
	// st.erase(3);   // as well
	cout << "count 3:" << st.count(3) << endl; // 0
	// 遍历 
	for(set<int>::iterator it=st.begin();it!=st.end();it++){
		cout << *it << " ";
	}
	cout << endl;
	// 反向遍历
	for(set<int>::reverse_iterator it=st.rbegin();it!=st.rend();it++){
		cout << *it << " ";
	}
	cout << endl;
	return 0;
} 
```

##### multiset

允许冗余，其余与set相同

```c++
#include <set>
#include <iostream>

using namespace std;

int main(){
	multiset<int> st;
	int n = 5;
	for(int i=0;i<n;i++)
		st.insert(i);
	for(int i=0;i<n;i++)
		st.insert(i);
	// 遍历  
	for(multiset<int>::iterator it=st.begin();it!=st.end();it++){
		cout << *it << " ";
	}
	cout << endl;
	// 计数
	cout << "count 3:" << st.count(3) << endl; // 2
	st.erase(st.find(3));
//	st.erase(3);   //  下一行结果为0 
	cout << "count 3:" << st.count(3) << endl; // 1
	// 遍历 
	for(multiset<int>::iterator it=st.begin();it!=st.end();it++){
		cout << *it << " ";
	}
	cout << endl;
	// 反向遍历
	for(multiset<int>::reverse_iterator it=st.rbegin();it!=st.rend();it++){
		cout << *it << " ";
	}
	cout << endl;
	return 0;
} 
```

##### map

+ | pair insert ( const value_type& x ) ：在map中插入键值对x，注意x是一个键值对，返回值 也是键值对：iterator代表新插入元素的位置，bool代 表释放插入成功 
+ | void erase ( iterator position )：删除position位置上的元素 
+ | size_type erase ( const key_type& x ) | 删除键值为x的元素
+ | void erase ( iterator first, iterator last ) | 删除[first, last)区间中的元素
+ | void swap ( map& mp ) | 交换两个map中的元素
+ | void clear ( ) | 将map中的元素清空
+ | iterator find ( const key_type& x ) ：在map中插入key为x的元素，找到返回该元素的位置 的迭代器，否则返回end 
+ | const_iterator find ( const key_type& x ) const：在map中插入key为x的元素，找到返回该元素的位置 的const迭代器，否则返回cend
+ | size_type count ( const key_type& x ) const：返回key为x的键值在map中的个数，注意map中key 是唯一的，因此该函数的返回值要么为0，要么为1，因 此也可以用该函数来检测一个key是否在map中 

##### multimap

tips：

+ 对于find来说multimap返回底层搜索树中序的第一个键值为key的元素的迭代器

+ 由于multimap容器允许键值冗余，调用 `[ ]` 运算符重载函数时，应该返回键值为key的哪一个元素的value的引用存在歧义，因此在multimap容器当中没有实现 `[ ]` 运算符重载函数



##### unordered_map / unordered_set

使用Hash实现，unordered_map查询单个key的时候效率比map高，但是要查询某一范围内的key值时比map效率低

```c++
std::unordered_map<std::string, std::int> umap; //定义

umap.insert(Map::value_type("test", 1));//增加

//根据key删除,如果没找到n=0
auto n = umap.erase("test")   //删除

auto it = umap.find(key) //改
if(it != umap.end()) 
    it->second = new_value; 

//map中查找x是否存在
umap.find(x) != map.end()//查
//或者
umap.count(x) != 0
```



### 数据结构

##### 线段树（with lazy tag）

+ 单点修改\区间修改 + 区间查询

```c++
typedef long long ll;
typedef struct node{
	ll sum;
	ll lazy;
}Node;

Node tree[4*MAXN];

void build(int l,int r,int now){
	if(l==r) tree[now].sum=a[l];
	else {
		int mid = l + ((r-l)>>1);
		build(l,mid,now*2);
		build(mid+1,r,now*2+1);
		tree[now].sum = tree[now*2].sum + tree[now*2+1].sum;
	}
	return ;
}

void update(int L,int R,ll k, int l,int r,int now){
	if(L==l && R==r) {
		tree[now].sum += (r-l+1)*k;
		tree[now].lazy += k;
		return ;
	}
	int mid = l + ((r-l)>>1);
	if(tree[now].lazy){
		tree[now*2].lazy += tree[now].lazy;
		tree[now*2].sum += (mid-l+1) * tree[now].lazy;
		tree[now*2+1].lazy += tree[now].lazy;
		tree[now*2+1].sum += (r-mid) * tree[now].lazy;
		tree[now].lazy=0;
	} 
	if(mid>=R) update(L,R,k,l,mid,now*2);
	else if(mid<L) update(L,R,k,mid+1,r,now*2+1);
	else {
		update(L,mid,k,l,mid,now*2);
		update(mid+1,R,k,mid+1,r,now*2+1);
	}
	tree[now].sum=tree[now*2].sum + tree[now*2+1].sum;
	return ;
}

ll query(int L,int R,int l,int r,int now){
	if(L==l && R==r) return tree[now].sum;
	int mid = l + ((r-l)>>1);
	if(tree[now].lazy){
		tree[now*2].lazy += tree[now].lazy;
		tree[now*2].sum += (mid-l+1) * tree[now].lazy;
		tree[now*2+1].lazy += tree[now].lazy;
		tree[now*2+1].sum += (r-mid) * tree[now].lazy;
		tree[now].lazy=0;
	}
	if(mid>=R) return query(L,R,l,mid,now*2);
	else if(mid<L) return query(L,R,mid+1,r,now*2+1);
	else return query(L,mid,l,mid,now*2) + query(mid+1,R,mid+1,r,now*2+1);
}
```

with × 和 + 操作

```c++
const int Nm=1e5+5;
const int Mm=1e5+5;
typedef long long ll;
int n,m,p;
ll a[Nm];
struct Node{
	ll sum,lazy1,lazy2;
}tree[Nm*4];

void build(int l,int r,int now){
	if(l==r) tree[now].sum=a[l];
	else{
		int mid=(l+r)/2;
		build(l,mid,now*2);
		build(mid+1,r,now*2+1);
		tree[now].sum=tree[now*2].sum+tree[now*2+1].sum;
	}
	tree[now].lazy1=1;
	tree[now].lazy2=0;
	return ;
}

void pushdown(int l,int r,int now){
	int mid=(l+r)/2;
	tree[now*2].sum=(tree[now*2].sum*tree[now].lazy1+tree[now].lazy2*(mid-l+1))%p;
	tree[now*2+1].sum=(tree[now*2+1].sum*tree[now].lazy1+tree[now].lazy2*(r-mid))%p;
	tree[now*2].lazy1=(tree[now*2].lazy1*tree[now].lazy1)%p;
	tree[now*2+1].lazy1=(tree[now*2+1].lazy1*tree[now].lazy1)%p;
	tree[now*2].lazy2=(tree[now*2].lazy2*tree[now].lazy1+tree[now].lazy2)%p;
	tree[now*2+1].lazy2=(tree[now*2+1].lazy2*tree[now].lazy1+tree[now].lazy2)%p;
	tree[now].lazy1=1;
	tree[now].lazy2=0;
}

void update(int op,int L,int R,ll k,int l,int r,int now){
	if(L==l&&R==r){
		if(op==1){
			tree[now].lazy1=tree[now].lazy1*k%p;
			tree[now].lazy2=tree[now].lazy2*k%p;
			tree[now].sum=tree[now].sum*k%p;
		}
		else{
			tree[now].lazy2+=k;
			tree[now].sum+=k*(r-l+1);
		}
		return;
	} 
	pushdown(l,r,now);
	int mid=(l+r)/2;
	if(R<=mid) update(op,L,R,k,l,mid,now*2);
	else if(L>mid) update(op,L,R,k,mid+1,r,now*2+1);
	else{
		update(op,L,mid,k,l,mid,now*2);
		update(op,mid+1,R,k,mid+1,r,now*2+1);
	}
	tree[now].sum=tree[now*2].sum+tree[now*2+1].sum;
	return ;
}

ll query(int L,int R,int l,int r,int now){
	if(L==l&&R==r) return tree[now].sum;
	pushdown(l,r,now);
	int mid=(l+r)/2;
	if(mid>=R) return query(L,R,l,mid,now*2);
	else if(mid<L) return query(L,R,mid+1,r,now*2+1);
	else return query(L,mid,l,mid,now*2)+query(mid+1,R,mid+1,r,now*2+1);
}

```



##### 树状数组

+ 单点修改 + 区间查询
+ 结合律  和  可差分(有逆运算)

```c++
const int MAXN=10005;
int n,m;
int a[MAXN], tree[MAXN];

int lowbit(int x){
	return x & (-x);
} 

// a[i] += x
void update(int i,int x){
	while(i<=n){
		tree[i] += x;
		i += lowbit(i);
	}
}

// sum(0,i]
int query(int i){
	int res=0;
	while(i){
		res += tree[i];
		i -= lowbit(i);
	}
	return res;
}
```



##### KMP

```c++
int nxt[MAXN];

int main(){
	string s1,s2;
	cin >> s1 >> s2;
	int sl1 = s1.size();
	int sl2 = s2.size();
	nxt[0]=-1;
	// build nxt array
	for(int i=1,j=-1;i<sl2;i++){
		while(s2[i]!=s2[j+1]){
			if(j==-1) break;
			j=next[j];
		}
		if(s2[i]==s2[j+1]) j++;
		next[i]=j;
	}
	// compare target string 
	for(int i=0,j=-1;i<sl1;i++){
		// s1[i] 和 s2[j+1] 比较， 直到相等或j==-1 
		while(s1[i]!=s2[j+1]){
			if(j==-1) break;
			j=next[j];
		}
		if(s2[i]==s2[j+1]) j++;
//		if(j==sl2-1) printf("%d\n",i-sl2+2); 	
		// 具体看情况输出比较结果 
	}
}
```

##### AC自动机

```c++

int tr[MAXN][26];
int ed[MAXN]; 		// 以状态 i 为终点的模式串
int fail[MAXN]; 	// Fail 数组 
int cnt=0;

void init(){
	for(int i=0;i<MAXN;i++){
		ed[i]=0;
		fail[i]=0;
		for(int j=0;j<26;j++)
			tr[i][j]=0;
	}
}

void insert(string s){
	int u=0;
	int sl = s.size();
	for(int i=0;i<sl;i++) {
		if(!tr[u][s[i]-'a']) tr[u][s[i]-'a'] = ++cnt;
		u = tr[u][s[i]-'a'];
	}
	ed[u] ++;
	return ;
}

void build_ac(){
	queue<int> que;
	while(que.size()) que.pop();
	for(int i=0;i<26;i++)
		if(tr[0][i]) que.push(tr[0][i]);
	while(que.size()) {
		int u = que.front();
		que.pop();
		for(int i=0;i<26;i++){
			if(tr[u][i]) {
				fail[tr[u][i]] = tr[fail[u]][i];
				que.push(tr[u][i]);
			} else {
				tr[u][i] = tr[fail[u]][i];
			}
		}
	}
}

int query(string t){
	int u=0, res=0;
	int tl=t.size();
	for(int i=0;i<tl;i++){
		u = tr[u][t[i]-'a'];	// state transfer
		for(int j=u; j&&ed[j]!=-1; j=fail[j]) {
			res += ed[j];
			ed[j]=-1;
		}
	}
	return res;
}

int main(){
	int n;
	string s;
	scanf("%d",&n);
	init();
	for(int i=0;i<n;i++){
		cin >> s;
		insert(s);
	}
	build_ac();
	cin >> s;
	cout << query(s);
	return 0;
} 
```



##### 后缀数组



##### 并查集

```c++
const int Nm=5005;
int father[Nm];
int n,m,p;

void init(){
	for(int i=1;i<=n;i++)
		father[i]=i;
	return ;
}

// 找到当前祖先
int find(int x){
	int r=x,p;
	while(father[r]!=r)
		r=father[r];
	while(father[x]!=x){
		p=father[x];
		father[x]=r;
		x=p;
	} 
	return r;
}

// 查询
int judge(int x,int y){
	int fx,fy;
	fx = find(x);
	fy = find(y);
	if(fx==fy) return 1;
	return 0;
}

// 合并
void union1(int x,int y){
	int fx,fy;
	fx=find(x);
	fy=find(y);
	father[fx]=fy;
}

```

##### st表

```c++
#include<cstdio>
const int Nm=1e5+5;
const int Mm=2e6+5;
int a[Nm];
int n,m;
int st[Nm][22];
int log[Nm];

int max(int x,int y){
	if(x>y) return x;
	return y;
}

void init(){
	int i,j;
	log[0]=-1;
	for(i=1;i<=Nm;i++)
		log[i]=log[i/2]+1;
	for(i=0;i<=n;i++)
		st[i][0]=a[i];
	for(j=1;(1<<j)<=n;j++){
		for(i=0;i+(1<<j)<=n;i++)
			st[i][j]=max(st[i][j-1],st[i+(1<<j-1)][j-1]);
	}
	return ;
}

int main(){
	scanf("%d%d",&n,&m);
	int i,j;
	for(i=0;i<n;i++){
		scanf("%d",&a[i]);
	}
	init();
	for(i=0;i<m;i++){
		int l,r;
		scanf("%d %d",&l,&r);
		l=l-1;
		r=r-1;
		int t=log[r-l+1];
		int ans=max(st[l][t],st[r-(1<<t)+1][t]);
		printf("%d\n",ans);
	}
	return 0;
}
```

##### Splay树

```c++
#include <cstdio>
const int N = 100005;
// 根节点 节点总数 某节点的父节点  某节点的左右孩子  某节点的值 某节点处的计数器 子树的规模
int rt, tot, fa[N], ch[N][2], val[N], cnt[N], sz[N];

struct Splay {
  // 在改变节点位置后，将节点 x 的 size 更新。
  void maintain(int x) { sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + cnt[x]; }
  // 判断节点x是父亲节点的左儿子还是右儿子。
  bool get(int x) { return x == ch[fa[x]][1]; }
  // 销毁节点 x
  void clear(int x) {
    ch[x][0] = ch[x][1] = fa[x] = val[x] = sz[x] = cnt[x] = 0;
  }

  // 旋转
  void rotate(int x) {
    int y = fa[x], z = fa[y], chk = get(x);
    ch[y][chk] = ch[x][chk ^ 1];
    if (ch[x][chk ^ 1]) fa[ch[x][chk ^ 1]] = y;
    ch[x][chk ^ 1] = y;
    fa[y] = x;
    fa[x] = z;
    if (z) ch[z][y == ch[z][1]] = x;
    maintain(y);
    maintain(x);
  }

  // 伸展
  void splay(int x) {
    for (int f = fa[x]; f = fa[x], f; rotate(x))
      if (fa[f]) rotate(get(x) == get(f) ? f : x);
    rt = x;
  }

  // 插入
  void ins(int k) {
    if (!rt) {
      val[++tot] = k;
      cnt[tot]++;
      rt = tot;
      maintain(rt);
      return;
    }
    int cur = rt, f = 0;
    while (1) {
      if (val[cur] == k) {
        cnt[cur]++;
        maintain(cur);
        maintain(f);
        splay(cur);
        break;
      }
      f = cur;
      cur = ch[cur][val[cur] < k];
      if (!cur) {
        val[++tot] = k;
        cnt[tot]++;
        fa[tot] = f;
        ch[f][val[f] < k] = tot;
        maintain(tot);
        maintain(f);
        splay(tot);
        break;
      }
    }
  }
  // 查询排名
  int rk(int k) {
    int res = 0, cur = rt;
    while (1) {
      if (k < val[cur]) {
        cur = ch[cur][0];
      } else {
        res += sz[ch[cur][0]];
        if (k == val[cur]) {
          splay(cur);
          return res + 1;
        }
        res += cnt[cur];
        cur = ch[cur][1];
      }
    }
  }
  // 查询排名第k的数
  int kth(int k) {
    int cur = rt;
    while (1) {
      if (ch[cur][0] && k <= sz[ch[cur][0]]) {
        cur = ch[cur][0];
      } else {
        k -= cnt[cur] + sz[ch[cur][0]];
        if (k <= 0) {
          splay(cur);
          return val[cur];
        }
        cur = ch[cur][1];
      }
    }
  }
  // 左子树中最右边的节点
  int pre() {
    int cur = ch[rt][0];
    if (!cur) return cur;
    while (ch[cur][1]) cur = ch[cur][1];
    splay(cur);
    return cur;
  }

  // 右子树中最右边的节点
  int nxt() {
    int cur = ch[rt][1];
    if (!cur) return cur;
    while (ch[cur][0]) cur = ch[cur][0];
    splay(cur);
    return cur;
  }
  
  // 删除操作
  void del(int k) {
    rk(k);
    if (cnt[rt] > 1) {
      cnt[rt]--;
      maintain(rt);
      return;
    }
    if (!ch[rt][0] && !ch[rt][1]) {
      clear(rt);
      rt = 0;
      return;
    }
    if (!ch[rt][0]) {
      int cur = rt;
      rt = ch[rt][1];
      fa[rt] = 0;
      clear(cur);
      return;
    }
    if (!ch[rt][1]) {
      int cur = rt;
      rt = ch[rt][0];
      fa[rt] = 0;
      clear(cur);
      return;
    }
    int cur = rt;
    int x = pre();
    fa[ch[cur][1]] = x;
    ch[x][1] = ch[cur][1];
    clear(cur);
    maintain(rt);
  }
} tree;

int main() {
  int n, opt, x;
  for (scanf("%d", &n); n; --n) {
    scanf("%d%d", &opt, &x);
    if (opt == 1)
      tree.ins(x);
    else if (opt == 2)
      tree.del(x);
    else if (opt == 3)
      printf("%d\n", tree.rk(x));
    else if (opt == 4)
      printf("%d\n", tree.kth(x));
    else if (opt == 5)
      tree.ins(x), printf("%d\n", val[tree.pre()]), tree.del(x);
    else
      tree.ins(x), printf("%d\n", val[tree.nxt()]), tree.del(x);
  }
  return 0;
```



### 经典算法

#### 最短路

##### Dijkstra

```c++
#include <iostream>
#include <utility>
#include <queue>
#include <vector>

using namespace std;

const int MAXN=100005;
const int INF=0x7fffffff;


typedef pair<int, int> P;
typedef struct edge{
	int to, cost;
}Edge;

int n;	// 顶点个数 
vector<Edge>gra[MAXN];
int d[MAXN];

void Dijkstra(int s){ // 起始点 
	priority_queue<P, vector<P>, greater<P> > que;
	for(int i=0;i<=n;i++)
		d[i]=INF;
	d[s]=0;
	que.push(P(0,s));
	while(!que.empty()){
		P p=que.top();
		que.pop();
		int v=p.second;
		if(d[v]<p.first) continue;
		for(int i=0;i<gra[v].size();i++){
			Edge e=gra[v][i];
			if(d[e.to]>d[v]+e.cost) {
				d[e.to]=d[v]+e.cost;
				que.push(P(d[e.to],e.to));
			}
		}
	}
	
}


int main(){
	int m,s;
	scanf("%d %d %d",&n,&m,&s);
	for(int i=0;i<m;i++){
		int from;
		Edge e;
		scanf("%d %d %d",&from,&e.to,&e.cost);
		gra[from].push_back(e);
	}
	Dijkstra(s);
	for(int i=1;i<=n;i++){
		printf("%d ",d[i]);
	}
	printf("\n");
	
	return 0;
	
} 
```

##### SPFA（队列优化）

```c++
struct edge {
  int v, w;
};

vector<edge> e[maxn];
int dis[maxn], cnt[maxn], vis[maxn];
queue<int> q;	// 队列中只存 “哪些结点可能会引起松弛操作”

bool spfa(int n, int s) {
  memset(dis, 63, sizeof(dis));
  dis[s] = 0, vis[s] = 1;
  q.push(s);
  while (!q.empty()) {
    int u = q.front();
    q.pop(), vis[u] = 0;
    for (auto ed : e[u]) { 	// 枚举每个
      int v = ed.v, w = ed.w;
      if (dis[v] > dis[u] + w) {
        dis[v] = dis[u] + w;
        cnt[v] = cnt[u] + 1;  // 记录最短路经过的边数
        if (cnt[v] >= n) return false; // 经过了负环
        
        if (!vis[v]) q.push(v), vis[v] = 1;
      }
    }
  }
  return true;
}
```

##### Floyd

`f[0][x][y]`：x与y的边权，或者0，或者 INF（当 x 与 y 间有直接相连的边的时候，为它们的边权；当 x==y 的时候为零，因为到本身的距离为零；当 x 与 y 没有直接相连的边的时候，为INF)。

`f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])`（`f[k-1][x][y]`，为不经过 k点的最短路径，而 `f[k-1][x][k]+f[k-1][k][y]`，为经过了 k 点的最短路）。

```c++
for (k = 1; k <= n; k++) {
  for (x = 1; x <= n; x++) {
    for (y = 1; y <= n; y++) {
      f[x][y] = min(f[x][y], f[x][k] + f[k][y]);
    }
  }
}
```

#### 最小生成树

##### Kruskal

```c++
// 存边 + 边排序 + 并查集判断是否处于同一连通域
const int Nm=200005;
int father[Nm];
int n,m;

typedef struct edge{
	int u,v;
	int cost;
}Edge;

Edge e[Nm];

int cmp(Edge e1, Edge e2){
	if(e1.cost < e2.cost) return 1;
	return 0;
} 

void init(){
	for(int i=1;i<=n;i++)
		father[i]=i;
}

int find(int x){
	int r=x,q;
	while(r!=father[r])
		r=father[r];
	while(x!=father[x]){
		q=father[x];
		father[x]=r;
		x=q;
	}
	return r;
}

int Kruskal(){
	sort(e,e+m,cmp);
	init();
	int cnt=0;
	int res=0;
	for(int i=0;i<m;i++){
		int u=e[i].u, v=e[i].v;
		int fu=find(u), fv=find(v);
		if(fu==fv) continue;
		cnt++;
		father[fu]=fv;
		res+=e[i].cost;
		if(cnt==n-1) break;
	}
	if(cnt==n-1) return res;
	return -1;
}
```

##### Prime

```c++
/// 前向星建图

const int MAXN=5005;
const int MAXE=200005;
const int INF=0x7fffffff;

int used[MAXN];
int dis[MAXN];
int n,m;

// graph
int head[MAXN];
int nxt[MAXE*2];
int cost[MAXE*2];
int to[MAXE*2];
int ecnt=0;
 
void init(){
	for(int i=1;i<=n;i++){
		dis[i]=INF;
		used[i]=0;
		head[i]=-1;
	}
	ecnt=0;
}

int min(int x,int y){
	if(x<y) return x;
	return y;
}

void add(int u,int v,int c){
	// u -> v
	nxt[ecnt]=head[u];
	head[u]=ecnt;
	cost[ecnt]=c;
	to[ecnt]=v;
	ecnt ++;
	
	// v -> u
	nxt[ecnt]=head[v];
	head[v]=ecnt;
	cost[ecnt]=c;
	to[ecnt]=u;
	ecnt ++;
	
	return ;
}

int Prime(){
	init();
	for(int i=0;i<m;i++){
		int u,v,c;
		scanf("%d %d %d",&u,&v,&c);
		add(u,v,c);
	}
//	cout << ecnt << endl;
	dis[1] = 0;
	int cnt=0;
	int res=0;
	while(1){
        // 选取一个最近的
		int v = -1;
		for(int u=1;u<=n;u++){
			if(used[u]) continue;
			if((v==-1||dis[u]<dis[v])&&dis[u]!=INF) v=u;
		}
		if(v==-1) break;
		used[v]=1;
		cnt ++;
		res+=dis[v];
        // 用最近的更新所有节点
		for(int i=head[v];i!=-1;i=nxt[i]){
			int u=to[i];
			dis[u] = min(dis[u],cost[i]);
		}
	}
	if(cnt!=n) return -1;
	return res;
	
	
	return 0;
}
```

#### 图的连通性

##### Tarjan

+ dfn[u]: u 被搜索的次序
+ low[u]：在u的子树中能够回溯到的最早的已经在栈中的节点

```c++
int dfn[N], low[N], dfncnt, s[N], in_stack[N], tp;
int scc[N], sc;  // 结点 i 所在 SCC 的编号
int sz[N];       // 强连通 i 的大小

void tarjan(int u) {
  low[u] = dfn[u] = ++dfncnt, s[++tp] = u, in_stack[u] = 1;
  for (int i = h[u]; i; i = e[i].nex) {
    const int &v = e[i].t;
    if (!dfn[v]) {
      tarjan(v);
      low[u] = min(low[u], low[v]);
    } else if (in_stack[v]) {
      low[u] = min(low[u], dfn[v]);
    }
  }
  if (dfn[u] == low[u]) {
    ++sc;  	// 该点即为割点，获得一个强连通分量
    while (s[tp] != u) {
      scc[s[tp]] = sc;
      sz[sc]++;
      in_stack[s[tp]] = 0;
      --tp;
    }
    scc[s[tp]] = sc;
    sz[sc]++;
    in_stack[s[tp]] = 0;
    --tp;
  }
}
```



#### 二分图

+ 二部图
+ 性质：不存在长度为奇数的环

##### 二分图的最大匹配

+ 匹配： 在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。
+ 匹配点、匹配边、未匹配点、未匹配边
+ 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。
+ 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。

##### 匈牙利算法 

（无权二分图的最大匹配） & 最小点覆盖（需要加上所有没有匹配成功的点）

```c++
struct Edge{
	int from, to, weight;
	Edge(int f,int t,int w):from(f),to(t),weight(w) {}
};

vector<int> graph[MAXN];
vector<Edge> edges;
int num_left, num_right;
int num_nodes;
int num_edges;
int lmatching[MAXN];	// 左边i号匹配的右边的号 
int rmatching[MAXN];	// rmatch[i]: 右边i号匹配的左边的号 
bool check[MAXN];		// 右边的某个节点 是否在当前的交替路径中 

bool dfs(int u){
	for(int i=0;i<graph[u].size();i++){
		int ei = graph[u][i];
		int v=edges[ei].to;
//		cout << u << " " << v << endl;
		if(!check[v]){ // 不在交替路中 
			check[v] = true;
			if(rmatching[v]==0 || dfs(rmatching[v])) { 
                // 未匹配或者找到一个增广路
				rmatching[v]=u;
				lmatching[u]=v;
				return true; 
			}
		}
	}
	return false;
}

int hungarian(){
	int ans=0;
	for(int i=1;i<=num_left;i++) lmatching[i]=0; 
	for(int i=1;i<=num_right;i++) rmatching[i]=0;
	for(int u=1;u<=num_left;u++){
		if(lmatching[u]==0){
			for(int j=1;j<=num_right;j++) check[j] = false;
			if(dfs(u)) ans++;
		}
	}
	return ans;
    // 最终的匹配情况存储在 lmatching 和 rmatching 中
}
```

##### KM算法

最大权完美匹配

 

#### 网络流



#### 拓扑排序

```c++
int a[MAXN];
long long last[MAXN];
long long earlist[MAXN];
int out[MAXN];
int in[MAXN];

vector<int> graph[MAXN];
vector<int> dgraph[MAXN];
int n,m;
long long ans1;


// 前向拓扑排序
void bfs(){
	// 获取earlist
	queue<int> que;
	while(que.size()) que.pop();
	for(int i=1;i<=n;i++){
		earlist[i]=0;
		if(in[i]) continue;
		que.push(i);
	}
	while(que.size()){
		int u = que.front();
		que.pop();
		for(int i=0;i<graph[u].size();i++){
			int v = graph[u][i];
			earlist[v] = max(earlist[v], earlist[u] + a[u]);
			in[v]--;
			if(!in[v]) que.push(v);
		}
	}
	return ;
}

// 反向拓扑排序
void bfs2(){
	// 获取earlist
	queue<int> que;
	while(que.size()) que.pop();
	
	for(int i=1;i<=n;i++){
		last[i]=ans1-a[i];
		if(out[i]) continue;
		que.push(i);
	}
	while(que.size()){
		int v = que.front();
		que.pop();
		for(int i=0;i<dgraph[v].size();i++){
			int u = dgraph[v][i];
			last[u] = min(last[u], last[v]-a[u]);
			out[u]--;
			if(!out[u]) que.push(u);
		}
	}
	return ;
}
```



### 数学

##### 快速幂

```c++
int quickpow(int x,int y){ // x ^ y
	int res = 1;
    while(y){
        if(y%2){
            res = res * x % MOD;
            x = x * x % MOD;
        }
        y >>= 1;
    }
    return x;
}
```

##### 求组合数

+ 费马小定理求逆元后计算组合数
    +  a^(p-1) == 1 mod p
    + =>    a^(p-2) == 1/a mod p

```c++
void computeC(){
	// f 阶乘
    f[0] = 1;
    f[1] = 1;
    for(int i=2;i<MAXN;i++){
        f[i]=f[i-1]*i%MOD;
    }
    // g[i]: i! 的逆元
    g[0]=1;
    for(int i=1;i<MAXN;i++){
        g[i]=quickpow(f[i],MOD-2)%MOD;
    }
}

// 组合数
ll Cnm(int n,int m){
    // n! / (n-m)! / m!
    return f[n]%MOD * g[n-m]%MOD * g[m]%MOD;
}
```

##### 素数筛法

```c++
int isprime[MAXN];
vector<int> prime;

void init(){
	prime.clear();
    for(int i=2;i<MAXN;i++) isprime[i] = 1;
    for(int i=2;i<MAXN;i++) {
        if(isprime[i]) {	// 质数
            prime.push_back(i);
            for(int j=i+i;j<MAXN;j+=i) isprime[j]=0;
        }
        // else { } 合数跳过
    }
}
```



##### 大整数乘法

```c++
string s[MAXN];

string addString(string a,string b){
	int carry=0;
	string res;
	int i=a.size()-1;
	int j=b.size()-1;
	while(i>=0 && j>=0){
		int num=carry+a[i]-'0'+b[j]-'0';
		res+=num%10+'0';
		carry=num/10;
		i--; j--;
	}
	while(i>=0){
		int num=carry+a[i]-'0';
		res+=num%10+'0';
		carry=num/10;
		i--;
	}
	while(j>=0){
		int num=carry+b[j]-'0';
		res+=num%10+'0';
		carry=num/10;
		j--;
	}
	if(carry>0)	res+=to_string(carry);
	reverse(res.begin(),res.end());
	return res;
} 

// x<=10 
string mulString(string a,int x){
	int carry=0;
	string res;
	for(int i=a.size()-1;i>=0;i--){
		int num=carry+(a[i]-'0')*x;
		res+=num%10+'0';
		carry=num/10; 
	}
	if(carry>0) res+=to_string(carry);
	reverse(res.begin(),res.end());
	return res;
}

// x>=10，单个位的乘法也可调用该函数，总会依位调用 `mulString`
string MulString(string a,string b){
	string res;
	for(int i=0;i<b.size();i++){
		int x=b[b.size()-1-i]-'0';
		string now=mulString(a,x);
		for(int j=0;j<i;j++)
			now=mulString(now,10);
		res=addString(res,now);
	}
	return res;
}

void init(){
	s[1]="1";
	for(int i=2;i<MAXN;i++){
		s[i] = MulString(s[i-1],to_string(i)); 
	}
	return ;
}

```

##### 进制转化

```c++
#include<string>
#include<algorithm>
// 将 m 进制下的大数 a 转化为 n 进制下的大数 
string conversion(int m,string a,int n){
	int l=a.size(), rem=0;
	string b;
	for(int i=0;i<l;){
		// 每次都做了一次除法，求出b的一位，i可能不增加，即a的位数不减少 
		// 本质是先转换成10进制，然后再使用竖式除 
		rem=0;
		for(int j=i;j<l;j++){
            int now;
			if(a[j]<='9'&&a[j]>='0') now=rem*m+a[j]-'0';	// 注意如果小写字母把A换成a
			else if(a[j]<='Z'&&a[j]>='A') now=rem*m+a[j]-'A'+10;
			int t=now%n;					// 余数 
			if(now/n<=9) a[j]=now/n + '0';	// 商 <= 9
			else a[j]=now/n - 10 + 'A'; 	// 商 >=10
			rem=t; 
		}
		// 将余数（即求得的位值）加入已有字符串b 
		b += to_string(rem);
		while(a[i]=='0') i++;
	}
	// 将b反转 
	reverse(b.begin(),b.end());
	return b;
}
```

##### FFT

```c++
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>

const double PI = acos(-1.0);

struct Complex {
  double x, y;

  Complex(double _x = 0.0, double _y = 0.0) {
    x = _x;
    y = _y;
  }

  Complex operator-(const Complex &b) const {
    return Complex(x - b.x, y - b.y);
  }

  Complex operator+(const Complex &b) const {
    return Complex(x + b.x, y + b.y);
  }

  Complex operator*(const Complex &b) const {
    return Complex(x * b.x - y * b.y, x * b.y + y * b.x);
  }
};

/*
 * 进行 FFT 和 IFFT 前的反置变换
 * 位置 i 和 i 的二进制反转后的位置互换
 *len 必须为 2 的幂
 */
void change(Complex y[], int len) {
  int i, j, k;

  for (int i = 1, j = len / 2; i < len - 1; i++) {
    if (i < j) std::swap(y[i], y[j]);

    // 交换互为小标反转的元素，i<j 保证交换一次
    // i 做正常的 + 1，j 做反转类型的 + 1，始终保持 i 和 j 是反转的
    k = len / 2;

    while (j >= k) {
      j = j - k;
      k = k / 2;
    }

    if (j < k) j += k;
  }
}

/*
 * 做 FFT
 *len 必须是 2^k 形式
 *on == 1 时是 DFT，on == -1 时是 IDFT
 */
void fft(Complex y[], int len, int on) {
  change(y, len);

  for (int h = 2; h <= len; h <<= 1) {
    Complex wn(cos(2 * PI / h), sin(on * 2 * PI / h));

    for (int j = 0; j < len; j += h) {
      Complex w(1, 0);

      for (int k = j; k < j + h / 2; k++) {
        Complex u = y[k];
        Complex t = w * y[k + h / 2];
        y[k] = u + t;
        y[k + h / 2] = u - t;
        w = w * wn;
      }
    }
  }

  if (on == -1) {
    for (int i = 0; i < len; i++) {
      y[i].x /= len;
    }
  }
}

const int MAXN = 200020;
Complex x1[MAXN], x2[MAXN];
char str1[MAXN / 2], str2[MAXN / 2];
int sum[MAXN];

int main() {
  while (scanf("%s%s", str1, str2) == 2) {
    int len1 = strlen(str1);
    int len2 = strlen(str2);
    int len = 1;

    while (len < len1 * 2 || len < len2 * 2) len <<= 1;

    for (int i = 0; i < len1; i++) x1[i] = Complex(str1[len1 - 1 - i] - '0', 0);

    for (int i = len1; i < len; i++) x1[i] = Complex(0, 0);

    for (int i = 0; i < len2; i++) x2[i] = Complex(str2[len2 - 1 - i] - '0', 0);

    for (int i = len2; i < len; i++) x2[i] = Complex(0, 0);

    fft(x1, len, 1);
    fft(x2, len, 1);

    for (int i = 0; i < len; i++) x1[i] = x1[i] * x2[i];

    fft(x1, len, -1);

    for (int i = 0; i < len; i++) sum[i] = int(x1[i].x + 0.5);

    for (int i = 0; i < len; i++) {
      sum[i + 1] += sum[i] / 10;
      sum[i] %= 10;
    }

    len = len1 + len2 - 1;

    while (sum[len] == 0 && len > 0) len--;

    for (int i = len; i >= 0; i--) printf("%c", sum[i] + '0');

    printf("\n");
  }

  return 0;
}
```


// wangyurzee7和Yazid是好朋友。

// wangyurzee7是一个繁忙的工作者，他每天都要写很多有趣的代码。

// Yazid开了一家有趣的公司，wangyurzee7当上了有趣的公司的项目经理。这家公司给码农们结算工资的方式也十分有趣，每个人的薪水正比于所写代码的长度。
// 不过很快，有趣的码农们学会了使用长长的变量名、大括号换行、增加长长的注释、tab换成空格等等方法，这让Yazid头疼不已。

// 有一天，wangyurzee7收到了Yazid的一个任务：在这个月结算工资之前，写一个脚本把程序中所有的注释全部去掉，
// 再将所有的函数名、变量名替换成单个字母，然后再进行统计代码长度。

// 这个任务非常简单，但wangyurzee7实在是太弱了，他只在github上找到了批量替换函数名的轮子，
// 而没有找到去掉注释和替换变量名的轮子，而且这个代码看起来不是那么有趣，wangyurzee7写不动。

// Yazid勃然大怒，他根本没想到这么简单的任务wangyurzee7都不能胜任。他把wangyurzee7狠狠地批判了一番。

// 当然啦，责任还是要由wangyurzee7来承担。无奈之下，他只好退而求其次，只需要针对C/C++代码，去掉里面的注释就向Yazid交差：

// 1、
// 单行注释//：一旦出现，并且被C/C++编译器认为是注释，那么从//符号开始到行末都被算作注释，比如下面程序的//233就会被算作注释：

// #include <cstdio>
// int main()
// {
//     printf("//");//233
//     return 0;
// }
// 并且如果单行注释最末尾的可见字符为\字符，则下一行从行初到行末均被认为是注释。

// 2、 多行注释/*
// */：一旦出现，并且被C/C++编译器认为是注释，那么从/*符号开始到*/符号结束都被算作注释，比如下面程序的1~4行就会被算作注释：

// /* Welcome to THUSCU2017!
//  * This is the easiest problem!
//  * \\\\\\\puts("\\\\\\\/**\///////");///////
//  *///
// int main(/**//**/){return!printf("%d",'//');}
// 3、
// 注释的处理方法：对于每个注释，将从注释的开始一直到注释的结束的字符串，替换成一个空格，其他地方的代码不允许做任何改动。将处理完的代码输出即可。比如上面的两段代码会变成下面这样（第一份代码第四行最末尾有一个空格，第二份代码第一行有两个空格）：

// -------------------------------------
// #include <cstdio>
// int main()
// {
//     printf("//");
//     return 0;
// }
// -------------------------------------

// int main(  ){return!printf("%d",'//');}
// -------------------------------------
// 既然要做的东西变少了，问题也就变得更简单了。请你帮帮可怜的wangyurzee7解决这个问题。

// 输入格式
// 输入有若干行，每一个测试样例都是一个能够在C/C++编译器下编译运行的代码，里面包含了若干注释。

// 输出格式
// 输出经过删除注释，并在原位置替换空格过后的C/C++代码。

// 数据范围
// 对于30%
// 的数据，保证只有单行注释//，但是并不保证不跨行。

// 对于另外40%
// 的数据，保证只有多行注释/* */，但是并不保证不跨行。

// 存在30%
// 的数据，保证注释没有跨行情况。

// 对于100%
// 的数据，保证代码总长度不超过20KB，所有字符都是常用可见字符或者空格、tab、换行符，并且不含ASCII标准之外的字符（如中文、拓展ASCII表等等），所有测试数据中的程序均可用C/C++编译器编译运行。保证以字符#作用的行（包含include、宏定义相关语句）中，引号成对出现，并且不包含以\结尾的单行注释；单行注释若出现跨行情况，必定是\字符之后紧跟换行符。

// 请注意考虑各种字符串情况，诸如：

// 字符串转义："/*\"//*/"

// 字符常量：'//"'

// 输入样例：
// #include <bits/stdc++.h>
// int main(int argc, char const *argv[])
// {
//     printf("\"../**/...//%s...","/etc//apt//sources.list");///\/*.\./*\
//     printf("\"../**/...//%s...","/etc//apt//sources.list");///\\.\./*\
//     return 0;/*
// }
// 输出样例：
// #include <bits/stdc++.h>
// int main(int argc, char const *argv[])
// {
//     printf("\"../**/...//%s...","/etc//apt//sources.list");
// }

// #include <cstdio>
#include <cstdio>
#include <iostream>
#include <string>
const int LEN = 1e9 + 1;
// char input_str[LEN];
std::string input_str = "";
std::string output_str = "";
int main()
{
	std::string line;
	while(std::getline(std::cin, line)) { input_str += line + "\n"; }
	// std::cout << input_str << "\nsize:" << input_str.size() << "\nlast" << input_str[10] << input_str[9] << "--\n" ;
	// 去除//注释
	char last_str = ' ';
	bool in_str = false;
	char last_str_str = ' ';
	// 去除 /*注释

	for(int i = 0, j = 0; i < input_str.size(); i++, j++)
	{
		if(in_str && ((input_str[i] == '"' && last_str_str == '"' && last_str != '\\') ||
					  (input_str[i] == '\'' && last_str_str == '\'' && last_str != '\\')))
		{
			// printf("unlock\n");
			in_str = false;
		}
		else if(!in_str && (input_str[i] == '"' || input_str[i] == '\'') && last_str != '\\')
		{
			// printf("lock:%d\n", i);
			// printf("==%c==\n", input_str[i]);
			// // printf("%c%c%c%c%c\n",
			// // 	   input_str[i - 2],
			// // 	   input_str[i - 1],
			// // 	   input_str[i],
			// // 	   input_str[i + 1],
			// // 	   input_str[i] + 2);
			// printf("%s", input_str.data() + i);
			in_str = true;
			last_str_str = input_str[i];
		}
		// 去除//注释
		if(in_str == false && input_str[i] == '/' && last_str == '/')
		{
			output_str[j - 1] = ' ';
			// printf("in\n");
			while(input_str[++i] != '\n')
			{
				if(input_str[i] == '\\' && input_str[i + 1] == '\n') { i++; }
			}
		}
		if(in_str == false && input_str[i] == '*' && last_str == '/')
		{
			output_str[j - 1] = ' ';
			char tmp_last = input_str[i];
			char tmp_last_last = ' ';
			bool tmp_if_in_str = false;
			while(input_str[++i] != '/' || tmp_last != '*' || tmp_if_in_str)
			{
				if(tmp_if_in_str &&
				   ((input_str[i] == '"' && tmp_last_last == '"' && tmp_last != '\\') ||
					(input_str[i] == '\'' && tmp_last_last == '\'' && tmp_last != '\\')))
				{
					// printf("unlock\n");
					// printf("%s", input_str.data() + i);
					tmp_if_in_str = false;
				}
				else if(!tmp_if_in_str && (input_str[i] == '"' || input_str[i] == '\'') &&
						tmp_last != '\\')
				{
					// printf("in lock\n");
					// printf("%s", input_str.data() + i);
					tmp_if_in_str = true;
					tmp_last_last = input_str[i];
				}
				if(in_str == false && input_str[i] == '/' && tmp_last == '/')
				{
					// output_str[j - 1] = ' ';
					// printf("in\n");
					while(input_str[++i] != '\n')
					{
						if(input_str[i] == '*' && input_str[i + 1] == '/') break;
						if(input_str[i] == '\\' && input_str[i + 1] == '\n') { i++; }
					}
				}
				tmp_last = input_str[i];
			}
			i++;
		}
		output_str += input_str[i];
		last_str = input_str[i];
	}
	std::cout << output_str;
}
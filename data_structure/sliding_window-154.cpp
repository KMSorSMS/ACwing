#include <deque>
#include <iostream>
#include <ostream>
/*
定一个大小为 n ≤ 10^6 的数组。
有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。
你只能在窗口中看到 k 个数字。
每次滑动窗口向右移动一个位置。
以下是一个例子：

该数组为 [1 3 -1 -3 5 3 6 7]，k 为 3。

窗口位置	                最小值	最大值
[1 3 -1] -3 5 3 6 7	        -1	    3
1 [3 -1 -3] 5 3 6 7	        -3	    3
1 3 [-1 -3 5] 3 6 7	        -3	    5
1 3 -1 [-3 5 3] 6 7	        -3	    5
1 3 -1 -3 [5 3 6] 7	         3	    6
1 3 -1 -3 5 [3 6 7]	         3	    7
你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。

输入格式
输入包含两行。

第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。

第二行有 n 个整数，代表数组的具体数值。

同行数据之间用空格隔开。

输出格式
输出包含两个。

第一行输出，从左至右，每个位置滑动窗口中的最小值。

第二行输出，从左至右，每个位置滑动窗口中的最大值。

输入样例：
8 3
1 3 -1 -3 5 3 6 7
输出样例：
-1 -3 -3 -3 3 3
3 3 5 5 6 7
*/
#define N 1000010
int nums[N];

int main()
{
	int n, k, i = 0;
	std::cin >> n >> k;
	std::deque<int> q;
	for(i = 0; i < n; i++) { std::cin >> nums[i]; }
	// 先找最小值
	for(i = 0; i < n; i++)
	{
		// 如果队列不为空，并且新的元素比队尾的元素更小
		while(q.size() && nums[q.back()] >= nums[i])
		{
			// 就将队尾出队，因为以后的最小值一定不是它
			q.pop_back();
		}
		// 将队列的队尾加入移入的元素
		q.push_back(i);
		// 维护窗口长度，保证不超
		if(i - q.front() + 1 > k) q.pop_front();
		// 输出结果,只有当窗口满之后
		if(i + 1 >= k) std::cout << nums[q.front()] << ' ';
	}
	std::cout << std::endl;
	q.clear();
	// 找最大值
	for(i = 0; i < n; i++)
	{
		// 如果队列不为空，并且新的元素比队尾的元素大或者相等
		while(q.size() && nums[q.back()] <= nums[i])
		{
			// 就弹出队尾元素，因为当新元素进入窗口之后，它就无论如何都不会是最大元素
			q.pop_back();
		}
		// 将队列的队尾元素加上新元素
		q.push_back(i);
		// 维护窗口长度，保证不超
		if(i - q.front() + 1 > k) q.pop_front();
		//足够长的时候打印
		if(i + 1 >= k) std::cout << nums[q.front()] << ' ';
	}
	std::cout << std::endl;
}

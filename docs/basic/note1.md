# basic part
## 排序
### 785-QuikSort 786-Select_QuickSort
最重要的是边界的思考，和对于比较点的选择：
每次无论左边还是右边的移动找可交换点，都应该不包含等于边界点的情况，因为如果跳过，那么就会出现死循环的情况，比如132，left从1开始一直移动到2，right会保持到2，那么就会一直卡在这个循环（在选择比较点为中点的情况），对于比较点的值，就算作left和right共同的分界线点，会进行交换.
写的时候记得几个特殊情况：1332，这会让left和right都停在3,所以if判断需要涵盖left==right的情况，并且以选取right作为分隔，这是因为除法的向下取整的原因，这里不能把left作为分界（除非向上取整，模板改成p[(left + right+1) >> 1];）<br> select 快排只是变形，我们找第K小的数只需要去除不必要的递归，因为每次递归会缩小区间，只需要递归第K小的数所在的区间即可
### 787-merge_sort 788 reverse_pairs
归并排序，分治法的典型应用，需要注意的是，归并排序的时间复杂度是O(nlogn),空间复杂度是O(n),因为需要一个额外的数组来存储排序后的结果，所以在空间复杂度上不如快排，但是在稳定性上要好于快排.这里细节上比快排简单，分界点取到mid，因为向下取整的原因，要分成[left,mid]，[mid+1,right]两个区间,不然12的时候是死循环。然后分成合并两个递归后保证了大小顺序的区间，最后记得复制结果到原始数组，因为递归返回后还会使用这个结果。<br> 寻找逆序对这里是一个简单的变形，因为要找到所有的逆序对，那么就分成一小段一小段找，和找第K大的数类似，因为对于排好序的区间，那么内部不存在逆序，只能是前一半区间对后一半区间可能存在有逆序对，这样就能先分割为小区间，然后再合并的时候找逆序对（从最小的，元素数量为1的区间开始左右合并），就能找完所有的逆序对。

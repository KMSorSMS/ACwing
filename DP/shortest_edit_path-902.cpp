/*
给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：

删除–将字符串 A 中的某个字符删除。
插入–在字符串 A 的某个位置插入某个字符。
替换–将字符串 A 中的某个字符替换为另一个字符。
现在请你求出，将 A 变为 B 至少需要进行多少次操作。

输入格式
第一行包含整数 n ，表示字符串 A 的长度。

第二行包含一个长度为 n 的字符串 A。

第三行包含整数 m，表示字符串 B 的长度。

第四行包含一个长度为 m 的字符串 B。

字符串中均只包含大小写字母。

输出格式
输出一个整数，表示最少操作次数。

数据范围
1≤n,m≤1000

输入样例：
10
AGTCTGACGC
11
AGTAAGTAGGC
输出样例：
4
*/
#include <algorithm>
#include <iostream>
#define N 1010
#define M 1010
char A[N], B[M];
int f[N][M];

int main()
{
	int n, m;
	std::cin >> n >> &A[1];
	std::cin >> m >> &B[1];
	for(int i = 1; i <= n; i++) { f[i][0] = i; }
	for(int j = 1; j <= m; j++) { f[0][j] = j; }
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= m; j++)
		{
			f[i][j] = std::min(f[i - 1][j] + 1, f[i][j - 1] + 1);
			if(A[i] == B[j])
			{
				// 如果相同，那么替换那一步就不需要换
				f[i][j] = std::min(f[i][j], f[i - 1][j - 1]);
			}
			else { f[i][j] = std::min(f[i][j], f[i - 1][j - 1] + 1); }
		}
	}
	std::cout << f[n][m] << "\n";
	return 0;
}

/*
思路：
定义 f[i][j] 是 A[1~i]经过若干操作到 B[1~j]的所有操作路线的集合的 最小值
那么：
f[i][j] = min(f[i-1][j]+1,f[i][j-1]+1,f[i-1]][j-1]+1(A[i]!=B[j])/0(A[i]==B[j]))
这里需要仔细想想，其实就是在我们得到 f[i][j]对应的集合的时候，我们可以保证用固定的方式去搜索，也就是锁定到最后一个元素 A[i]（增加的话就是默认加在 A[i]旁边）的情况
删除，那么就是原来 f[i-1][j] + 1, 也就是把之前的匹配上，然后去掉当前的
增加，f[i][j-1],也就是得在 A[i]后面再加，也就是原本匹配 B[j-1]然后去增加新的 B[j]到A 后面
更改，这里就是把 A[i]换掉，换成 B[j]，最后一种就是不变，那么就相当于不换
*/
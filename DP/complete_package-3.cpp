/*
有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。
第 i 种物品的体积是 v_i，价值是 w_i。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

输入格式
第一行两个整数，N，V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行两个整数 v_i,w_i，用空格隔开，分别表示第 i 种物品的体积和价值。

输出格式
输出一个整数，表示最大价值。

数据范围
0<N,V≤1000
0<v_i,w_i≤1000

输入样例
4 5
1 2
2 4
3 4
4 5
输出样例：
10
*/

#include <algorithm>
#include <iostream>
#define N 1010
#define V 1010

int v_[N], w_[N];
int f[V];

int main()
{
	int n, v;
	std::cin >> n >> v;
	for(int i = 1; i <= n; i++) std::cin >> v_[i] >> w_[i];
	// 开始做遍历
	for(int i = 1; i <= n; i++)
	{
		for(int j = v_[i]; j <= v; j++) { f[j] = std::max(f[j], f[j - v_[i]] + w_[i]); }
	}
	std::cout << f[v] << "\n";
}

/*
思路：
从朴素的状态分析出发，我们设定 f[i][j]代表前 i 种物品，在体积小于 j的情况下的最大价值
那么，在已知 f[i-1][j]的情况下，如何推算下一个状态 f[i][j]呢：
1. 选 0 个 i 种物品，f[i][j] = f[i-1][j]
2. 选 1 个 i 种物品，f[i][j] = f[i-1][j - v[i]] + w[i]
3. 选 2 个 i 种物品，f[i][j] = f[i-1][j - 2 * v[i]] + 2 * w[i];
...
k. 选 k 个 i 种物品，f[i][j] = f[i-1][j - k * v[i]] + k * w[i];
然后从这 k 种情况里面挑出最大值。
这里注意到，对于后面的选 1 ~ k 个 i 种物品的情况，我们对比f[i][j - v[i]]
f[i][j - v[i]] = max(f[i-1][j - v[i]],f[i-1][j- 2*v[i]] + w[i], ... , f[i-1][j - k*v[i]] + (k-1) * w[i])
事实上，它就等于前面 2～k情况 - w[i]
所以有
f[i][j] = max(f[i-1][j],f[i][j-v[i]] + w[i])
*/
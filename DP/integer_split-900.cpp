/*
一个正整数 n 可以表示成若干个正整数之和，形如：n=n_1+n_2+…+n_k，其中 n1≥n2≥…≥nk,k≥1。

我们将这样的一种表示称为正整数 n 的一种划分。

现在给定一个正整数 n，请你求出 n 共有多少种不同的划分方法。

输入格式
共一行，包含一个整数 n。

输出格式
共一行，包含一个整数，表示总划分数量。

由于答案可能很大，输出结果请对 10^9+7 取模。

数据范围
1≤n≤1000

输入样例:
5
输出样例：
7
*/

#include <iostream>
#define N 1010
#define MOD (1000000000 + 7)

int f[N];

int main()
{
	int n;
	std::cin >> n;
	// for(int i = 0; i <= n; i++) f[i][0] = 1;
	f[0] = 1;
	for(int i = 1; i <= n; i++)
	{
		for(int j = 1; j <= n; j++)
		{
			if(j >= i)
				f[j] = (f[j] + f[j - i]) % MOD;
			else
				f[j] = f[j] % MOD;
		}
	}
	std::cout << f[n] << "\n";
}

/*
思路：
考虑对比完全背包问题，可以看做有 n 件物品，从 1～i 件物品的容量依次是 1～i
我们的属性就是选择的方法数量。
于是，f[i][j]代表 1～i 件物品，容量刚好是 j的所有选择的数量，我们有
f[i][j] = f[i-1][j] + f[i-1][j-i] + f[i-1][j-2*i] + ... + f[i-1][j-k*i]
f[i][j-i] =           f[i-1][j-i] + f[i-1][j-2*i] + ... + f[i-1][j-k*i]
于是可以化简得到：
f[i][j] = f[i-1][j] + f[i][j-i]

*/